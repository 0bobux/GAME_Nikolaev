# Инициализация игры
board = [['.' for _ in range(5)] for _ in range(4)] # Игровое поле 4х5
players = ['X', 'O', 'Y'] # Список символов, представляющий трех игроков
scores = [0, 0, 0] # Список, который будет хранить штрафные очки каждого игрока
current_player = 0 # Индекс текущего игрока (0 для первого игрока, 1 для второго и 2 для третьего).

# Функция для отображения игрового поля
def display_board():
    print("\nТекущее состояние поля:")
    for row in board:
        print(' '.join(row)) # Объединяет элементы строки в одну строку с пробелами между ними.
    print()

# Основной игровой цикл
while True:
    display_board()
    print(f"Игрок {players[current_player]}, введите НОМЕР СТРОКИ и НОМЕР СТОЛБЦА (в формате \"x y\"):")

    while True:
        try:
            x, y = map(int, input().split()) # Получает строку от пользователя и разбивает ее на два отдельных значения c помощью split. Преобразует эти значения в целые числа с помощью map.
            x -= 1  # Преобразуем координаты к 0-индексации
            y -= 1  # Преобразуем координаты к 0-индексации
            if 0 <= x < 4 and 0 <= y < 5 and board[x][y] == '.':
                break
            else:
                print("Некорректный ход. Попробуйте снова.")
        except (ValueError, IndexError):
            print("Некорректный ввод. Пожалуйста, введите два целых числа.")

    board[x][y] = players[current_player] # После того как игрок ввел корректные координаты, в выбранную клетку записывается символ текущего игрока.

    # Проверка окончания игры
    if all(cell != '.' for row in board for cell in row): # Если все элементы в итерируемом объекте истинны - True. Проверяет, заполнены ли все клетки на игровом поле.
        break

    current_player = (current_player + 1) % 3 # Переключает на следующего игрока.

# Итоги игры
display_board()
print("Игра окончена!")

# Подсчет штрафных очков в конце игры
penalty = [0, 0, 0] # Храним штрафные очки для каждого из трех игроков.
directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] # Возможные смещения для проверки соседних клеток. Каждая пара чисел (dx, dy) описывает направление.
                                                                                    # dx - изменение по строкам (по вертикали).dy — изменение по столбцам (по горизонтали).

for i in range(4):
    for j in range(5):
        if board[i][j] != '.':
            player_idx = players.index(board[i][j]) # Метод index() ищет переданное значение в списке players и возвращает индекс первого вхождения этого значения.
            for dx, dy in directions:
                ni, nj = i + dx, j + dy # Рассчитывает новый индекс строки и столбца для соседней клетки.
                if 0 <= ni < 4 and 0 <= nj < 5 and board[ni][nj] == board[i][j]: # Проверяет, находится ли соседняя клетка в пределах игрового поля. И проверяет, равен ли символ в соседней клетке символу в текущей клетке.
                    penalty[player_idx] += 1 # Если да, увеличиваем штрафные очки определенного игрока.

scores = penalty # Штрафы сохраняются в переменной scores.

# Вывод результатов
for idx, score in enumerate(scores): # Возвращает пары (индекс, значение) для каждого элемента в списке scores.
    print(f"Игрок {players[idx]}: {score} штрафных очков.") # idx будет индексом игрока в списке players, а score — соответствующим значением штрафных очков из списка scores.

# Определение победителя
min_score = min(scores) # Находит минимальное значение штрафных очков.
winners = [players[i] for i in range(3) if scores[i] == min_score] # Проверяет, имеет ли игрок с индексом i штрафные очки, равные min_score и заносит их в список winners. Это позволяет учесть всех победителей, если их несколько.

if len(winners) == 1:
    print(f"Победитель: Игрок {winners[0]}")
else:
    print(f"Ничья между игроками: {', '.join(winners)}") # Объединяет имена всех игроков, которые находятся в списке winners, в одну строку, разделяя их запятыми.

